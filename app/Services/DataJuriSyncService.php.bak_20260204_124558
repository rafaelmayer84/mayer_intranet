<?php

namespace App\Services;

use App\Models\Cliente;
use App\Models\Processo;
use App\Models\Movimento;
use App\Models\IntegrationLog;
use App\Services\ClassificacaoService;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;
use Illuminate\Support\Facades\DB;
use Exception;

class DataJuriSyncService
{
    private $baseUrl = 'https://api.datajuri.com.br';
    private $token;
    private $clientId;
    private $secretId;
    private $username;
    private $password;
    private $perPage = 100;
    private $classificacaoService;

    public function __construct(ClassificacaoService $classificacaoService = null)
    {
        $this->clientId = env('DATAJURI_CLIENT_ID');
        $this->secretId = env('DATAJURI_SECRET_ID');
        $this->username = env('DATAJURI_EMAIL');
        $this->password = env('DATAJURI_PASSWORD');
        $this->classificacaoService = $classificacaoService ?? app(ClassificacaoService::class);
    }

    /**
     * Autenticar na API DataJuri
     */
    public function authenticate()
    {
        try {
            $credentials = base64_encode("{$this->clientId}:{$this->secretId}");

            $response = Http::withHeaders([
                'Authorization' => "Basic {$credentials}",
                'Content-Type' => 'application/x-www-form-urlencoded'
            ])->asForm()->post("{$this->baseUrl}/oauth/token", [
                'grant_type' => 'password',
                'username' => $this->username,
                'password' => $this->password
            ]);

            if ($response->successful()) {
                $this->token = $response->json()['access_token'];
                return true;
            }

            $this->logError('DataJuri', 'Autenticação', 'Falha na autenticação: ' . $response->body());
            return false;

        } catch (Exception $e) {
            $this->logError('DataJuri', 'Autenticação', $e->getMessage());
            return false;
        }
    }

    /**
     * Sincronizar todas as entidades com paginação
     */
    public function syncAll()
    {
        if (!$this->authenticate()) {
            return [
                'success' => false,
                'message' => 'Falha na autenticação com DataJuri'
            ];
        }

        $results = [
            'pessoas' => $this->syncPessoasComPaginacao(),
            'processos' => $this->syncProcessosComPaginacao(),
            'movimentos' => $this->syncMovimentosComPaginacao(),
        ];

        return [
            'success' => true,
            'results' => $results
        ];
    }

    /**
     * Sincronizar Pessoas (Clientes) com paginação
     * CORRIGIDO: Agora solicita e mapeia TODOS os campos necessários
     */
    public function syncPessoasComPaginacao()
    {
        try {
            $page = 1;
            $totalSincronizadas = 0;
            $totalErros = 0;

            do {
                try {
                    $response = Http::withHeaders([
                        'Authorization' => "Bearer {$this->token}",
                        'Content-Type' => 'application/json'
                    ])->get("{$this->baseUrl}/v1/entidades/Pessoa", [
                        'page' => $page,
                        'pageSize' => $this->perPage,
                        // ===============================================================
                        // CORREÇÃO CRÍTICA: Campos expandidos para incluir todos os dados
                        // ===============================================================
                        'campos' => implode(',', [
                            // Dados básicos
                            'id',
                            'nome',
                            'email',
                            'telefone',
                            'celular',              // NOVO: Campo de celular
                            'numeroDocumento',      // NOVO: CPF/CNPJ
                            'tipoPessoa',           // NOVO: Tipo correto (PF/PJ)
                            'dataCadastro',         // NOVO: Data de cadastro
                            'cliente',              // NOVO: Flag se é cliente
                            'statusPessoa',         // NOVO: Situação
                            // Endereço principal
                            'enderecoprua',         // NOVO: Rua
                            'enderecopnumero',      // NOVO: Número
                            'enderecopcomplemento', // NOVO: Complemento
                            'enderecopbairro',      // NOVO: Bairro
                            'enderecopcidade',      // NOVO: Cidade
                            'enderecopestado',      // NOVO: Estado
                            'enderecopcep',         // NOVO: CEP
                            'enderecoppais',        // NOVO: País
                            // Campos calculados (valores financeiros)
                            'totalContasReceber',         // NOVO: Total contas a receber
                            'totalContasReceberVencidas', // NOVO: Total vencidas
                            'valorTotalContasAbertas',    // NOVO: Valor em aberto
                        ])
                    ]);

                    if (!$response->successful()) {
                        throw new Exception('Falha ao buscar pessoas: ' . $response->body());
                    }

                    $data = $response->json();
                    $pessoas = $data['rows'] ?? [];

                    if (empty($pessoas)) {
                        break;
                    }

                    foreach ($pessoas as $pessoa) {
                        try {
                            // ===============================================================
                            // CORREÇÃO: Mapeamento completo de todos os campos
                            // ===============================================================
                            
                            // Concatenar endereço completo
                            $endereco = $this->montarEnderecoCompleto($pessoa);
                            
                            // Determinar telefone (prioriza celular se telefone vazio)
                            $telefone = trim($pessoa['telefone'] ?? '');
                            if (empty($telefone)) {
                                $telefone = trim($pessoa['celular'] ?? '');
                            }
                            
                            // Parsear valores monetários (vem como string "1.234,56")
                            $valorCarteira = $this->parseValorBrasileiro($pessoa['totalContasReceber'] ?? 0);
                            
                            // Parsear data de cadastro
                            $dataCadastro = $this->parseDataBrasileira($pessoa['dataCadastro'] ?? null);

                            $cliente = Cliente::updateOrCreate(
                                ['datajuri_id' => $pessoa['id'] ?? null],
                                [
                                    'nome' => substr($pessoa['nome'] ?? '', 0, 255),
                                    'email' => substr($pessoa['email'] ?? '', 0, 255),
                                    'telefone' => substr($telefone, 0, 20),
                                    // =========================================
                                    // CAMPOS QUE ESTAVAM NULL - AGORA MAPEADOS
                                    // =========================================
                                    'cpf_cnpj' => substr($pessoa['numeroDocumento'] ?? '', 0, 20),
                                    'tipo' => substr($pessoa['tipoPessoa'] ?? 'PF', 0, 50),
                                    'endereco' => substr($endereco, 0, 500),
                                    'valor_carteira' => $valorCarteira,
                                    'data_primeiro_contato' => $dataCadastro,
                                    // =========================================
                                    'ativo' => true,
                                    'payload_raw' => json_encode($pessoa, JSON_UNESCAPED_UNICODE),
                                ]
                            );
                            $totalSincronizadas++;
                        } catch (Exception $e) {
                            Log::warning("Erro ao sincronizar pessoa {$pessoa['id']}: " . $e->getMessage());
                            $totalErros++;
                        }
                    }

                    $page++;
                } catch (Exception $e) {
                    Log::error("Erro na página {$page} de pessoas: " . $e->getMessage());
                    break;
                }
            } while (count($pessoas) === $this->perPage);

            $this->logSuccess('DataJuri', 'Pessoas', "Sincronizadas {$totalSincronizadas} pessoas ({$totalErros} erros)");
            return ['success' => true, 'count' => $totalSincronizadas, 'errors' => $totalErros];

        } catch (Exception $e) {
            $this->logError('DataJuri', 'Pessoas', $e->getMessage());
            return ['success' => false, 'error' => $e->getMessage()];
        }
    }

    /**
     * Montar endereço completo a partir dos campos individuais
     * 
     * @param array $pessoa Dados da pessoa da API
     * @return string Endereço formatado
     */
    private function montarEnderecoCompleto(array $pessoa): string
    {
        $partes = [];
        
        // Rua + Número
        $rua = trim($pessoa['enderecoprua'] ?? '');
        $numero = trim($pessoa['enderecopnumero'] ?? '');
        if (!empty($rua)) {
            $partes[] = $rua . (!empty($numero) ? ', ' . $numero : '');
        }
        
        // Complemento
        $complemento = trim($pessoa['enderecopcomplemento'] ?? '');
        if (!empty($complemento)) {
            $partes[] = $complemento;
        }
        
        // Bairro
        $bairro = trim($pessoa['enderecopbairro'] ?? '');
        if (!empty($bairro)) {
            $partes[] = $bairro;
        }
        
        // Cidade/Estado
        $cidade = trim($pessoa['enderecopcidade'] ?? '');
        $estado = trim($pessoa['enderecopestado'] ?? '');
        if (!empty($cidade) || !empty($estado)) {
            $partes[] = trim($cidade . '/' . $estado, '/');
        }
        
        // CEP
        $cep = trim($pessoa['enderecopcep'] ?? '');
        if (!empty($cep)) {
            $partes[] = 'CEP: ' . $cep;
        }
        
        return implode(' - ', array_filter($partes));
    }

    /**
     * Sincronizar Processos com paginação
     */
    public function syncProcessosComPaginacao()
    {
        try {
            $page = 1;
            $totalSincronizadas = 0;
            $totalErros = 0;

            do {
                try {
                    $response = Http::withHeaders([
                        'Authorization' => "Bearer {$this->token}",
                        'Content-Type' => 'application/json'
                    ])->get("{$this->baseUrl}/v1/entidades/Processo", [
                        'page' => $page,
                        'pageSize' => $this->perPage,
                        'campos' => 'id,pasta,numero,status,situacao,tipoAcao,valorCausa,proprietario.nome,cliente.nome,dataCadastro'
                    ]);

                    if (!$response->successful()) {
                        throw new Exception('Falha ao buscar processos: ' . $response->body());
                    }

                    $data = $response->json();
                    $processos = $data['rows'] ?? [];

                    if (empty($processos)) {
                        break;
                    }

                    foreach ($processos as $processo) {
                        try {
                            Processo::updateOrCreate(
                                ['datajuri_id' => $processo['id'] ?? null],
                                [
                                    'pasta' => substr($processo['pasta'] ?? '', 0, 50),
                                    'numero' => substr($processo['numero'] ?? '', 0, 50),
                                    'status' => substr($processo['status'] ?? '', 0, 50),
                                    'situacao' => substr($processo['situacao'] ?? '', 0, 100),
                                    'tipo_acao' => substr($processo['tipoAcao'] ?? '', 0, 100),
                                    'valor_causa' => $this->parseValorBrasileiro($processo['valorCausa'] ?? 0),
                                    'advogado_responsavel' => substr($processo['proprietario.nome'] ?? '', 0, 255),
                                    'cliente_nome' => substr($processo['cliente.nome'] ?? '', 0, 255),
                                    'data_cadastro' => $this->parseDataBrasileira($processo['dataCadastro'] ?? null),
                                ]
                            );
                            $totalSincronizadas++;
                        } catch (Exception $e) {
                            Log::warning("Erro ao sincronizar processo {$processo['id']}: " . $e->getMessage());
                            $totalErros++;
                        }
                    }

                    $page++;
                } catch (Exception $e) {
                    Log::error("Erro na página {$page} de processos: " . $e->getMessage());
                    break;
                }
            } while (count($processos) === $this->perPage);

            $this->logSuccess('DataJuri', 'Processos', "Sincronizados {$totalSincronizadas} processos ({$totalErros} erros)");
            return ['success' => true, 'count' => $totalSincronizadas, 'errors' => $totalErros];

        } catch (Exception $e) {
            $this->logError('DataJuri', 'Processos', $e->getMessage());
            return ['success' => false, 'error' => $e->getMessage()];
        }
    }

    /**
     * Sincronizar Movimentos financeiros com paginação
     */
    public function syncMovimentosComPaginacao()
    {
        try {
            $page = 1;
            $totalSincronizados = 0;
            $totalErros = 0;

            do {
                try {
                    $response = Http::withHeaders([
                        'Authorization' => "Bearer {$this->token}",
                        'Content-Type' => 'application/json'
                    ])->timeout(60)->get("{$this->baseUrl}/v1/entidades/Movimento", [
                        'page' => $page,
                        'pageSize' => $this->perPage,
                        'campos' => 'id,data,valorComSinal,descricao,observacao,planoConta.nomeCompleto,planoContaId,contaId,pessoa.nome,pessoaId,conciliado,relativoa,dataCadastro'
                    ]);

                    if (!$response->successful()) {
                        throw new Exception('Falha ao buscar movimentos: ' . $response->body());
                    }

                    $data = $response->json();
                    $movimentos = $data['rows'] ?? [];

                    if (empty($movimentos)) {
                        break;
                    }

                    foreach ($movimentos as $movimento) {
                        try {
                            // Extrair código do plano de contas
                            $codigoPlano = $this->extrairCodigoPlano($movimento['planoConta.nomeCompleto'] ?? '');
                            
                            // Parsear valor (pode conter HTML e formato brasileiro)
                            $valor = $this->parseValorBrasileiro($movimento['valorComSinal'] ?? 0);
                            
                            // Parsear data
                            $data = $this->parseDataBrasileira($movimento['data'] ?? null);
                            
                            // Determinar classificação baseada no código do plano
                            $classificacao = null;
                            if ($codigoPlano && $this->classificacaoService) {
                                $classificacao = $this->classificacaoService->classificar($codigoPlano);
                            }

                            Movimento::updateOrCreate(
                                ['datajuri_id' => $movimento['id'] ?? null],
                                [
                                    'data' => $data,
                                    'valor' => abs($valor),
                                    'tipo' => $valor >= 0 ? 'C' : 'D',
                                    'descricao' => substr($movimento['descricao'] ?? '', 0, 500),
                                    'observacao' => $movimento['observacao'] ?? null,
                                    'codigo_plano' => $codigoPlano,
                                    'plano_contas' => substr($movimento['planoConta.nomeCompleto'] ?? '', 0, 500),
                                    'classificacao' => $classificacao,
                                    'conciliado' => ($movimento['conciliado'] ?? 'Não') === 'Sim',
                                    'pessoa_nome' => substr($movimento['pessoa.nome'] ?? '', 0, 255),
                                    'pessoa_id' => $movimento['pessoaId'] ?? null,
                                    'ano' => $data ? (int) date('Y', strtotime($data)) : null,
                                    'mes' => $data ? (int) date('m', strtotime($data)) : null,
                                ]
                            );
                            $totalSincronizados++;
                        } catch (Exception $e) {
                            Log::warning("Erro ao sincronizar movimento {$movimento['id']}: " . $e->getMessage());
                            $totalErros++;
                        }
                    }

                    $page++;
                } catch (Exception $e) {
                    Log::error("Erro na página {$page} de movimentos: " . $e->getMessage());
                    break;
                }
            } while (count($movimentos) === $this->perPage);

            $this->logSuccess('DataJuri', 'Movimentos', "Sincronizados {$totalSincronizados} movimentos ({$totalErros} erros)");
            return ['success' => true, 'count' => $totalSincronizados, 'errors' => $totalErros];

        } catch (Exception $e) {
            $this->logError('DataJuri', 'Movimentos', $e->getMessage());
            return ['success' => false, 'error' => $e->getMessage()];
        }
    }

    /**
     * Extrair código do plano de contas da string completa
     * Exemplo: "3.01 RESULTADO:3.01.01 RECEITA:3.01.01.01 - Receita PF" → "3.01.01.01"
     */
    private function extrairCodigoPlano(?string $nomeCompleto): ?string
    {
        if (empty($nomeCompleto)) {
            return null;
        }

        // Padrão: código de 4 níveis (ex: 3.01.01.01)
        if (preg_match('/(\d+\.\d+\.\d+\.\d+)\s*-/', $nomeCompleto, $matches)) {
            return $matches[1];
        }

        // Fallback: 3 níveis
        if (preg_match('/(\d+\.\d+\.\d+)\s*-/', $nomeCompleto, $matches)) {
            return $matches[1];
        }

        // Fallback: 2 níveis
        if (preg_match('/(\d+\.\d+)\s*-/', $nomeCompleto, $matches)) {
            return $matches[1];
        }

        return null;
    }

    /**
     * Parsear valor monetário brasileiro (pode conter HTML)
     * Exemplos:
     * - "1.234,56" → 1234.56
     * - "<span class='valor-positivo'>830,09</span>" → 830.09
     * - "<span class='valor-negativo'>-150,00</span>" → -150.00
     */
    private function parseValorBrasileiro($valor): float
    {
        if (is_numeric($valor)) {
            return (float) $valor;
        }

        if (!is_string($valor)) {
            return 0.0;
        }

        // Detectar se é negativo pela classe CSS ou pelo sinal
        $negativo = (stripos($valor, 'valor-negativo') !== false) ||
                    (strpos($valor, '-') !== false && strpos($valor, 'positivo') === false);

        // Remover tags HTML
        $valor = strip_tags($valor);

        // Remover espaços e caracteres especiais (exceto números, vírgula, ponto e sinal)
        $valor = preg_replace('/[^\d,.\-]/', '', $valor);

        // Formato brasileiro: pontos são separadores de milhar, vírgula é decimal
        // Remover pontos de milhar
        $valor = str_replace('.', '', $valor);
        // Trocar vírgula por ponto decimal
        $valor = str_replace(',', '.', $valor);

        $float = (float) $valor;

        // Aplicar sinal negativo se detectado
        if ($negativo && $float > 0) {
            $float = -$float;
        }

        return $float;
    }

    /**
     * Parsear data brasileira (DD/MM/YYYY) para formato MySQL (YYYY-MM-DD)
     */
    private function parseDataBrasileira(?string $data): ?string
    {
        if (empty($data)) {
            return null;
        }

        // Formato DD/MM/YYYY
        if (preg_match('/(\d{2})\/(\d{2})\/(\d{4})/', $data, $matches)) {
            return "{$matches[3]}-{$matches[2]}-{$matches[1]}";
        }

        // Formato DD/MM/YYYY HH:mm (com hora)
        if (preg_match('/(\d{2})\/(\d{2})\/(\d{4})\s+\d{2}:\d{2}/', $data, $matches)) {
            return "{$matches[3]}-{$matches[2]}-{$matches[1]}";
        }

        // Se já estiver no formato correto ou outro formato reconhecível
        try {
            $timestamp = strtotime($data);
            if ($timestamp !== false) {
                return date('Y-m-d', $timestamp);
            }
        } catch (Exception $e) {
            // Ignora erro de parsing
        }

        return null;
    }

    /**
     * Atualizar contadores de clientes (total_processos, total_contratos)
     * Deve ser chamado APÓS a sincronização de processos
     */
    public function atualizarContadoresClientes()
    {
        try {
            // Atualizar total_processos
            DB::statement("
                UPDATE clientes c
                SET total_processos = (
                    SELECT COUNT(*) 
                    FROM processos p 
                    WHERE p.cliente_nome = c.nome 
                    OR p.datajuri_cliente_id = c.datajuri_id
                )
            ");

            // Atualizar data_ultimo_contato baseado no último processo/movimento
            DB::statement("
                UPDATE clientes c
                SET data_ultimo_contato = (
                    SELECT MAX(p.data_cadastro)
                    FROM processos p
                    WHERE p.cliente_nome = c.nome
                    OR p.datajuri_cliente_id = c.datajuri_id
                )
                WHERE EXISTS (
                    SELECT 1 FROM processos p
                    WHERE p.cliente_nome = c.nome
                    OR p.datajuri_cliente_id = c.datajuri_id
                )
            ");

            $this->logSuccess('DataJuri', 'Contadores', 'Contadores de clientes atualizados');
            return ['success' => true];

        } catch (Exception $e) {
            $this->logError('DataJuri', 'Contadores', $e->getMessage());
            return ['success' => false, 'error' => $e->getMessage()];
        }
    }

    // =========================================================================
    // Métodos wrapper para compatibilidade com commands existentes
    // =========================================================================
    
    public function syncPessoas()
    {
        return $this->syncPessoasComPaginacao();
    }

    public function syncProcessos()
    {
        return $this->syncProcessosComPaginacao();
    }

    public function syncMovimentos()
    {
        return $this->syncMovimentosComPaginacao();
    }

    /**
     * Registrar log de sucesso
     */
    private function logSuccess($sistema, $tipo, $mensagem)
    {
        try {
            IntegrationLog::create([
                'sync_id' => Str::uuid(),
                'tipo' => $tipo,
                'fonte' => 'datajuri',
                'status' => 'concluido',
                'registros_processados' => 0
            ]);
        } catch (Exception $e) {
            Log::error("Erro ao registrar log de sucesso: " . $e->getMessage());
        }

        Log::info("[{$sistema}] {$tipo}: {$mensagem}");
    }

    /**
     * Registrar log de erro
     */
    private function logError($sistema, $tipo, $mensagem)
    {
        try {
            IntegrationLog::create([
                'sync_id' => Str::uuid(),
                'tipo' => $tipo,
                'fonte' => 'datajuri',
                'status' => 'erro',
                'mensagem_erro' => $mensagem
            ]);
        } catch (Exception $e) {
            Log::error("Erro ao registrar log de erro: " . $e->getMessage());
        }

        Log::error("[{$sistema}] {$tipo}: {$mensagem}");
    }

    /**
     * Classifica um movimento usando o ClassificacaoService
     */
    private function classificarMovimento(?string $codigoPlano, ?string $tipo): string
    {
        return $this->classificacaoService->classificar($codigoPlano, $tipo);
    }
}
