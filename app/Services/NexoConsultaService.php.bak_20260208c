<?php

namespace App\Services;

use App\Models\Cliente;
use App\Models\NexoAuthAttempt;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\DB;
use Carbon\Carbon;

class NexoConsultaService
{
    // ================================================================
    // CONSTANTES
    // ================================================================

    const MAX_TENTATIVAS = 3;
    const BLOQUEIO_MINUTOS = 30;
    const CAMPOS_AUTH = ['email', 'cpf_cnpj', 'data_nascimento', 'nome'];

    // ================================================================
    // 1. IDENTIFICAR CLIENTE
    // ================================================================

    /**
     * Identifica cliente pelo telefone.
     * Retorna: encontrado, nome, bloqueado
     */
    public function identificarCliente(string $telefone): array
    {
        $telefoneNorm = $this->normalizarTelefone($telefone);

        Log::info('[NEXO-CONSULTA] identificarCliente', ['telefone' => $telefoneNorm]);

        // Verificar bloqueio
        $attempt = NexoAuthAttempt::where('telefone', $telefoneNorm)->first();
        if ($attempt && $attempt->estaBloqueado()) {
            return [
                'encontrado' => 'sim',
                'nome' => '',
                'bloqueado' => 'sim',
            ];
        }

        // Buscar cliente pelo telefone (match exato)
        $cliente = $this->buscarClientePorTelefone($telefoneNorm);

        if (!$cliente) {
            Log::info('[NEXO-CONSULTA] Cliente nÃ£o encontrado', ['telefone' => $telefoneNorm]);
            return [
                'encontrado' => 'nao',
                'nome' => '',
                'bloqueado' => 'nao',
            ];
        }

        Log::info('[NEXO-CONSULTA] Cliente encontrado', ['id' => $cliente->id, 'nome' => $cliente->nome]);

        return [
            'encontrado' => 'sim',
            'nome' => $cliente->nome ?? '',
            'bloqueado' => 'nao',
        ];
    }

    // ================================================================
    // 2. GERAR PERGUNTAS DE AUTENTICAÃ‡ÃƒO
    // ================================================================

    /**
     * Gera 2 perguntas aleatÃ³rias com 3 opÃ§Ãµes (1 correta + 2 falsas).
     * Campos possÃ­veis: email, cpf_cnpj, data_nascimento, nome
     */
    public function gerarPerguntasAuth(string $telefone): array
    {
        $telefoneNorm = $this->normalizarTelefone($telefone);
        $cliente = $this->buscarClientePorTelefone($telefoneNorm);

        if (!$cliente) {
            return ['erro' => 'Cliente nÃ£o encontrado'];
        }

        // Selecionar 2 campos disponÃ­veis (que tenham dado preenchido)
        $camposDisponiveis = $this->getCamposDisponiveis($cliente);

        if (count($camposDisponiveis) < 2) {
            Log::warning('[NEXO-CONSULTA] Menos de 2 campos disponÃ­veis para auth', [
                'cliente_id' => $cliente->id,
                'campos' => $camposDisponiveis,
            ]);
            return ['erro' => 'Dados insuficientes para autenticaÃ§Ã£o'];
        }

        // Sortear 2 campos
        $camposSorteados = collect($camposDisponiveis)->shuffle()->take(2)->values()->all();

        $resultado = [];
        foreach ($camposSorteados as $i => $campo) {
            $n = $i + 1;
            $pergunta = $this->montarPergunta($cliente, $campo);
            $resultado["pergunta{$n}_texto"] = $pergunta['texto'];
            $resultado["pergunta{$n}_campo"] = $campo;
            $resultado["pergunta{$n}_opcao_a"] = $pergunta['opcoes'][0];
            $resultado["pergunta{$n}_opcao_b"] = $pergunta['opcoes'][1];
            $resultado["pergunta{$n}_opcao_c"] = $pergunta['opcoes'][2];
        }

        Log::info('[NEXO-CONSULTA] Perguntas geradas', [
            'cliente_id' => $cliente->id,
            'campos' => $camposSorteados,
        ]);

        return $resultado;
    }

    // ================================================================
    // 3. VALIDAR AUTENTICAÃ‡ÃƒO
    // ================================================================

    /**
     * Valida as respostas da autenticaÃ§Ã£o multifator.
     */
    public function validarAuth(string $telefone, array $respostas): array
    {
        $telefoneNorm = $this->normalizarTelefone($telefone);
        $cliente = $this->buscarClientePorTelefone($telefoneNorm);

        if (!$cliente) {
            return ['valido' => 'nao', 'tentativas_restantes' => '0', 'bloqueado' => 'sim'];
        }

        // Obter ou criar registro de tentativas
        // Limpar tentativas antigas (>24h)
        NexoAuthAttempt::where('updated_at', '<', now()->subHours(24))->delete();

        $attempt = NexoAuthAttempt::firstOrCreate(
            ['telefone' => $telefoneNorm],
            ['tentativas' => 0, 'bloqueado' => false]
        );

        // Verificar bloqueio
        if ($attempt->estaBloqueado()) {
            return ['valido' => 'nao', 'tentativas_restantes' => '0', 'bloqueado' => 'sim'];
        }

        // Validar cada pergunta
        $acertos = 0;
        foreach ([1, 2] as $n) {
            $campo = $respostas["pergunta{$n}_campo"] ?? '';
            $valor = $respostas["pergunta{$n}_valor"] ?? '';

            if ($this->validarResposta($cliente, $campo, $valor)) {
                $acertos++;
            }
        }

        Log::info('[NEXO-AUTH-DEBUG]', ['respostas' => $respostas, 'cliente_nome' => $cliente->nome, 'cliente_email' => $cliente->email, 'acertos' => $acertos]);
        $valido = ($acertos === 2);

        if ($valido) {
            // Reset tentativas
            $attempt->update([
                'tentativas' => 0,
                'bloqueado' => false,
                'bloqueado_ate' => null,
            ]);

            Log::info('[NEXO-CONSULTA] Auth OK', ['cliente_id' => $cliente->id]);

            return ['valido' => 'sim', 'tentativas_restantes' => (string) self::MAX_TENTATIVAS, 'bloqueado' => 'nao'];
        }

        // Incrementar tentativas
        $tentativas = $attempt->tentativas + 1;
        $bloqueado = $tentativas >= self::MAX_TENTATIVAS;

        $attempt->update([
            'tentativas' => $tentativas,
            'bloqueado' => $bloqueado,
            'bloqueado_ate' => $bloqueado ? Carbon::now()->addMinutes(self::BLOQUEIO_MINUTOS) : null,
            'ultimo_tentativa' => Carbon::now(),
        ]);

        $restantes = max(0, self::MAX_TENTATIVAS - $tentativas);

        Log::warning('[NEXO-CONSULTA] Auth FALHOU', [
            'cliente_id' => $cliente->id,
            'tentativas' => $tentativas,
            'bloqueado' => $bloqueado,
        ]);

        return [
            'valido' => 'nao',
            'tentativas_restantes' => (string) $restantes,
            'bloqueado' => $bloqueado ? 'true' : 'false',
        ];
    }

    // ================================================================
    // 4. CONSULTA STATUS (lista processos ou responde direto)
    // ================================================================

    /**
     * Lista processos do cliente ou retorna status direto (se 1 processo).
     */
    public function consultaStatus(string $telefone): array
    {
        $telefoneNorm = $this->normalizarTelefone($telefone);
        $cliente = $this->buscarClientePorTelefone($telefoneNorm);

        if (!$cliente) {
            return ['erro' => 'Cliente nÃ£o encontrado'];
        }

        // Buscar processos ativos
        $processos = DB::table('processos')
            ->where('cliente_id', $cliente->id)
            ->where('status', 'Ativo')
            ->select('id', 'pasta', 'titulo', 'adverso_nome', 'numero')
            ->orderBy('pasta')
            ->get();

        $total = $processos->count();

        if ($total === 0) {
            return [
                'selecao_necessaria' => 'nao',
                'mensagem' => '',
                'resposta' => 'NÃ£o encontramos processos ativos vinculados ao seu cadastro. Se acredita que isso Ã© um erro, entre em contato com nossa equipe.',
                'total' => '0',
            ];
        }

        if ($total === 1) {
            // Consultar direto
            $processo = $processos->first();
            $resposta = $this->montarRespostaProcesso($cliente, $processo);

            return [
                'selecao_necessaria' => 'nao',
                'mensagem' => '',
                'resposta' => $resposta,
                'total' => '1',
            ];
        }

        // MÃºltiplos processos â€” precisa seleÃ§Ã£o
        $resultado = [
            'selecao_necessaria' => 'sim',
            'mensagem' => "VocÃª possui {$total} processos ativos. Qual deseja consultar?",
            'resposta' => '',
            'total' => (string) $total,
        ];

        // Montar lista compacta (limite 1024 chars SendPulse)
        $lista = '';
        foreach ($processos as $i => $proc) {
            $n = $i + 1;
            $adverso = $proc->adverso_nome ?: 'N/A';
            if (mb_strlen($adverso) > 25) {
                $adverso = mb_substr($adverso, 0, 23) . '..';
            }
            $pasta = $proc->pasta;
            $linha = "{$n}. {$pasta} x {$adverso}\n";
            if (mb_strlen($lista . $linha) > 950) {
                $lista .= "(+mais)\n";
                break;
            }
            $lista .= $linha;
        }
        $resultado['resposta'] = $lista;
        return $resultado;
    }

    // ================================================================
    // 5. CONSULTA STATUS PROCESSO ESPECÃFICO
    // ================================================================

    /**
     * Consulta processo especÃ­fico por pasta.
     */
    public function consultaStatusProcesso(string $telefone, string $pasta): array
    {
        $telefoneNorm = $this->normalizarTelefone($telefone);
        $cliente = $this->buscarClientePorTelefone($telefoneNorm);

        if (!$cliente) {
            return ['erro' => 'Cliente nÃ£o encontrado'];
        }

        $processo = DB::table('processos')
            ->where('cliente_id', $cliente->id)
            ->where('pasta', $pasta)
            ->first();

        if (!$processo) {
            return [
                'resposta' => 'Processo nÃ£o encontrado. Verifique com nossa equipe.',
                'processo_descricao' => '',
            ];
        }

        $adverso = $processo->adverso_nome ?: 'N/A';

        return [
            'resposta' => $this->montarRespostaProcesso($cliente, $processo),
            'processo_descricao' => "Pasta {$processo->pasta} Ã— {$adverso}",
        ];
    }

    // ================================================================
    // MÃ‰TODOS PRIVADOS â€” AUTENTICAÃ‡ÃƒO
    // ================================================================

    private function getCamposDisponiveis(object $cliente): array
    {
        $campos = [];

        if (!empty($cliente->email)) {
            $campos[] = 'email';
        }
        if (!empty($cliente->cpf_cnpj) || !empty($cliente->cpf) || !empty($cliente->cnpj)) {
            $campos[] = 'cpf_cnpj';
        }
        if (!empty($cliente->data_nascimento)) {
            $campos[] = 'data_nascimento';
        }
        // Nome sempre disponÃ­vel como fallback
        if (!empty($cliente->nome) && count($campos) < 4) {
            $campos[] = 'nome';
        }

        return $campos;
    }

    private function montarPergunta(object $cliente, string $campo): array
    {
        switch ($campo) {
            case 'email':
                return $this->perguntaEmail($cliente);
            case 'cpf_cnpj':
                return $this->perguntaCpfCnpj($cliente);
            case 'data_nascimento':
                return $this->perguntaAnoNascimento($cliente);
            case 'nome':
                return $this->perguntaNome($cliente);
            default:
                return ['texto' => 'Erro', 'opcoes' => ['A', 'B', 'C']];
        }
    }

    private function perguntaEmail(object $cliente): array
    {
        $email = strtolower(trim($cliente->email));
        $mascarado = $this->mascararEmail($email);

        // Gerar 2 emails falsos plausÃ­veis
        $parts = explode('@', $email);
        $dominio = $parts[1] ?? 'gmail.com';
        $dominiosFake = ['gmail.com', 'hotmail.com', 'outlook.com', 'yahoo.com.br', 'terra.com.br'];
        $dominiosFake = array_diff($dominiosFake, [$dominio]);
        $dominiosFake = array_values($dominiosFake);

        $nomeParte = substr($parts[0], 0, 2);
        $falso1 = $nomeParte . str_pad(rand(10, 99), 2, '0') . '@' . $dominiosFake[0];
        $falso2 = $nomeParte . str_pad(rand(10, 99), 2, '0') . '@' . ($dominiosFake[1] ?? $dominiosFake[0]);

        $opcoes = [$email, $falso1, $falso2];
        shuffle($opcoes);

        return [
            'texto' => "Qual Ã© o seu e-mail cadastrado?",
            'opcoes' => $opcoes,
        ];
    }

    private function perguntaCpfCnpj(object $cliente): array
    {
        $doc = $cliente->cpf_cnpj ?: $cliente->cpf ?: $cliente->cnpj ?: '';
        $docLimpo = preg_replace('/\D/', '', $doc);

        if (strlen($docLimpo) < 4) {
            return ['texto' => 'Erro', 'opcoes' => ['A', 'B', 'C']];
        }

        $ultimos4 = substr($docLimpo, -4);

        // Gerar 2 finais falsos
        $falso1 = str_pad(rand(1000, 9999), 4, '0', STR_PAD_LEFT);
        $falso2 = str_pad(rand(1000, 9999), 4, '0', STR_PAD_LEFT);
        while ($falso1 === $ultimos4) $falso1 = str_pad(rand(1000, 9999), 4, '0', STR_PAD_LEFT);
        while ($falso2 === $ultimos4 || $falso2 === $falso1) $falso2 = str_pad(rand(1000, 9999), 4, '0', STR_PAD_LEFT);

        $tipo = strlen($docLimpo) > 11 ? 'CNPJ' : 'CPF';
        $opcoes = ["***{$ultimos4}", "***{$falso1}", "***{$falso2}"];
        shuffle($opcoes);

        return [
            'texto' => "Quais sÃ£o os Ãºltimos 4 dÃ­gitos do seu {$tipo}?",
            'opcoes' => $opcoes,
        ];
    }

    private function perguntaAnoNascimento(object $cliente): array
    {
        $dataNasc = $cliente->data_nascimento;
        if (is_string($dataNasc)) {
            try {
                $dataNasc = Carbon::parse($dataNasc);
            } catch (\Exception $e) {
                return ['texto' => 'Erro', 'opcoes' => ['A', 'B', 'C']];
            }
        }

        $anoReal = (int) $dataNasc->format('Y');
        $falso1 = $anoReal + rand(1, 4);
        $falso2 = $anoReal - rand(1, 4);

        $opcoes = [(string) $anoReal, (string) $falso1, (string) $falso2];
        shuffle($opcoes);

        return [
            'texto' => "Qual Ã© o seu ano de nascimento?",
            'opcoes' => $opcoes,
        ];
    }

    private function perguntaNome(object $cliente): array
    {
        $nomeReal = trim($cliente->nome);
        $partes = explode(' ', $nomeReal);
        $primeiroNome = $partes[0];

        // Gerar nomes falsos com mesmo primeiro nome
        $sobrenomesFake = ['Santos', 'Oliveira', 'Silva', 'Souza', 'Pereira', 'Costa', 'Ferreira', 'Almeida', 'Rodrigues', 'Lima'];
        shuffle($sobrenomesFake);

        $falso1 = $primeiroNome . ' ' . $sobrenomesFake[0];
        $falso2 = $primeiroNome . ' ' . $sobrenomesFake[1];

        // Garantir que falsos sÃ£o diferentes do real
        while (strtolower($falso1) === strtolower($nomeReal)) {
            $falso1 = $primeiroNome . ' ' . array_shift($sobrenomesFake);
        }
        while (strtolower($falso2) === strtolower($nomeReal) || $falso2 === $falso1) {
            $falso2 = $primeiroNome . ' ' . array_pop($sobrenomesFake);
        }

        $opcoes = [$nomeReal, $falso1, $falso2];
        shuffle($opcoes);

        return [
            'texto' => "Qual Ã© o seu nome completo cadastrado?",
            'opcoes' => $opcoes,
        ];
    }

    private function validarResposta(object $cliente, string $campo, string $valor): bool
    {
        $valor = trim($valor);

        switch ($campo) {
            case 'email':
                return strtolower($valor) === strtolower(trim($cliente->email ?? ''));

            case 'cpf_cnpj':
                $doc = $cliente->cpf_cnpj ?: $cliente->cpf ?: $cliente->cnpj ?: '';
                $docLimpo = preg_replace('/\D/', '', $doc);
                $ultimos4 = substr($docLimpo, -4);
                // Valor vem como "***1234", extrair Ãºltimos 4
                $valorLimpo = preg_replace('/\D/', '', $valor);
                $valorLimpo = substr($valorLimpo, -4);
                return $valorLimpo === $ultimos4;

            case 'data_nascimento':
                $dataNasc = $cliente->data_nascimento;
                if (is_string($dataNasc)) {
                    try { $dataNasc = Carbon::parse($dataNasc); } catch (\Exception $e) { return false; }
                }
                return (string) $dataNasc->format('Y') === (string) $valor;

            case 'nome':
                return strtolower($valor) === strtolower(trim($cliente->nome ?? ''));

            default:
                return false;
        }
    }

    // ================================================================
    // MÃ‰TODOS PRIVADOS â€” CONSULTA PROCESSOS
    // ================================================================

    private function montarRespostaProcesso(object $cliente, object $processo): string
    {
        $adverso = $processo->adverso_nome ?: 'N/A';
        $pasta = $processo->pasta ?? '?';
        $numero = $processo->numero_processo ?? '';

        // Buscar Ãºltimo andamento
        $ultimoAndamento = DB::table('atividades_datajuri')
            ->where('processo_id', $processo->id)
            ->where('tipo', 'Andamento')
            ->orderByDesc('data')
            ->first();

        // Buscar prÃ³ximo prazo
        $proximoPrazo = DB::table('atividades_datajuri')
            ->where('processo_id', $processo->id)
            ->where('tipo', 'Prazo')
            ->where('data', '>=', Carbon::today()->toDateString())
            ->orderBy('data')
            ->first();

        // Montar resposta humanizada
        $resposta = "ðŸ“‹ *Processo: Pasta {$pasta}*\n";
        $resposta .= "ðŸ‘¥ {$cliente->nome} Ã— {$adverso}\n";

        if ($numero) {
            $resposta .= "ðŸ“Ž NÂº {$numero}\n";
        }

        $resposta .= "\n";

        if ($ultimoAndamento) {
            $dataAnd = $this->formatarData($ultimoAndamento->data);
            $descricao = strip_tags($ultimoAndamento->descricao ?? '');
            $descricao = mb_substr($descricao, 0, 300);
            $resposta .= "ðŸ“Œ *Ãšltimo andamento ({$dataAnd}):*\n{$descricao}\n\n";
        } else {
            $resposta .= "ðŸ“Œ *Ãšltimo andamento:* Sem registros recentes.\n\n";
        }

        if ($proximoPrazo) {
            $dataPrazo = $this->formatarData($proximoPrazo->data);
            $descPrazo = strip_tags($proximoPrazo->descricao ?? 'Prazo processual');
            $resposta .= "â³ *PrÃ³ximo prazo ({$dataPrazo}):*\n{$descPrazo}\n\n";
        }

        $resposta .= "ðŸ’¡ Em caso de dÃºvidas, fale com nossa equipe.";

        return $resposta;
    }

    // ================================================================
    // MÃ‰TODOS PRIVADOS â€” UTILITÃRIOS
    // ================================================================

    private function normalizarTelefone(string $telefone): string
    {
        // Remove tudo que nÃ£o Ã© nÃºmero
        $tel = preg_replace('/\D/', '', $telefone);

        // Garantir formato brasileiro com 55
        if (strlen($tel) === 11) {
            $tel = '55' . $tel;
        } elseif (strlen($tel) === 10) {
            $tel = '55' . $tel;
        }

        return $tel;
    }

    private function buscarClientePorTelefone(string $telefoneNorm): ?object
    {
        // Montar lista de formatos possÃ­veis para busca
        $formatos = [$telefoneNorm];

        // Se comeÃ§a com 55, tentar sem o cÃ³digo do paÃ­s
        if (str_starts_with($telefoneNorm, '55') && strlen($telefoneNorm) > 10) {
            $formatos[] = substr($telefoneNorm, 2); // sem 55
        }

        // Se tem 10 dÃ­gitos (DDD+8), tentar com 9 adicionado
        $semPais = str_starts_with($telefoneNorm, '55') ? substr($telefoneNorm, 2) : $telefoneNorm;
        if (strlen($semPais) === 10) {
            $formatos[] = substr($semPais, 0, 2) . '9' . substr($semPais, 2);
            $formatos[] = '55' . substr($semPais, 0, 2) . '9' . substr($semPais, 2);
        }

        // Se tem 11 dÃ­gitos (DDD+9+8), tentar sem o 9
        if (strlen($semPais) === 11 && $semPais[2] === '9') {
            $formatos[] = substr($semPais, 0, 2) . substr($semPais, 3);
        }

        $formatos = array_unique($formatos);

        $cliente = DB::table('clientes')
            ->whereIn('telefone', $formatos)
            ->first();

        // Se nÃ£o encontrou na tabela clientes, tentar via wa_conversations linkada
        if (!$cliente) {
            $conv = DB::table('wa_conversations')
                ->where('phone', $telefoneNorm)
                ->whereNotNull('linked_cliente_id')
                ->first();

            if ($conv) {
                $cliente = DB::table('clientes')->where('id', $conv->linked_cliente_id)->first();
            }
        }

        return $cliente;
    }

    private function mascararEmail(string $email): string
    {
        $parts = explode('@', $email);
        $local = $parts[0];
        $domain = $parts[1] ?? '';
        $masked = substr($local, 0, 2) . str_repeat('*', max(3, strlen($local) - 2));
        return $masked . '@' . $domain;
    }

    private function formatarData($data): string
    {
        if (!$data) return 'â€”';

        try {
            if ($data instanceof \DateTimeInterface) {
                return $data->format('d/m/Y');
            }
            return Carbon::parse($data)->format('d/m/Y');
        } catch (\Exception $e) {
            return (string) $data;
        }
    }
}
