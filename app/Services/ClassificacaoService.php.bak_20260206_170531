<?php

namespace App\Services;

use App\Models\ClassificacaoRegra;
use App\Models\Movimento;
use App\Models\IntegrationLog;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class ClassificacaoService
{
    /**
     * Classifica um movimento baseado em regras configuráveis
     *
     * @param string|null $codigoPlano Código do plano de contas
     * @param string|null $tipoMovimento Tipo do movimento (RECEITA, DESPESA)
     * @return string Classificação encontrada
     */
    public function classificar(?string $codigoPlano, ?string $tipoMovimento = null): string
    {
        // Se não tem código, tenta classificar por tipo
        if (empty($codigoPlano)) {
            return $this->classificarPorTipo($tipoMovimento);
        }

        // 1. Buscar regra na tabela (exata ou wildcard)
        $regra = ClassificacaoRegra::buscarRegraMaisEspecifica($codigoPlano);

        if ($regra) {
            return $regra->classificacao;
        }

        // 2. Tentar inferir pela estrutura do código contábil
        $classificacaoInferida = $this->inferirPorPadraoContabil($codigoPlano);
        if ($classificacaoInferida !== 'PENDENTE_CLASSIFICACAO') {
            return $classificacaoInferida;
        }

        // 3. Fallback: classificar por tipo
        return $this->classificarPorTipo($tipoMovimento);
    }

    /**
     * Infere classificação baseada em padrões contábeis conhecidos
     * Baseado na estrutura do plano de contas DataJuri
     */
    private function inferirPorPadraoContabil(string $codigo): string
    {
        // ========================================
        // RECEITAS BRUTAS (3.01.01.xx)
        // ========================================
        
        // Receita PF: 3.01.01.01 (Contrato PF)
        if ($codigo === '3.01.01.01') {
            return 'RECEITA_PF';
        }

        // Receita PJ: 3.01.01.02 (Contrato PJ)
        if ($codigo === '3.01.01.02') {
            return 'RECEITA_PJ';
        }

        // Receita PF Quota Litis: 3.01.01.03
        if ($codigo === '3.01.01.03') {
            return 'RECEITA_PF';
        }

        // Receita PJ Quota Litis: 3.01.01.05
        if ($codigo === '3.01.01.05') {
            return 'RECEITA_PJ';
        }

        // Receitas genéricas 3.01.01.xx - default PF
        if (preg_match('/^3\.01\.01\.\d+$/', $codigo)) {
            return 'RECEITA_PF';
        }

        // ========================================
        // DEDUÇÕES (3.01.02.xx)
        // ========================================
        if (str_starts_with($codigo, '3.01.02')) {
            return 'DEDUCAO';
        }

        // ========================================
        // DESPESAS OPERACIONAIS (3.02.xx)
        // ========================================
        if (str_starts_with($codigo, '3.02')) {
            return 'DESPESA';
        }

        // ========================================
        // RECEITAS FINANCEIRAS (3.03.xx)
        // ========================================
        if (str_starts_with($codigo, '3.03')) {
            return 'RECEITA_FINANCEIRA';
        }

        // ========================================
        // DESPESAS FINANCEIRAS (3.04.xx)
        // ========================================
        if (str_starts_with($codigo, '3.04')) {
            return 'DESPESA_FINANCEIRA';
        }

        // ========================================
        // PADRÕES GENÉRICOS
        // ========================================

        // Qualquer coisa em 3.01 que não seja despesa
        if (str_starts_with($codigo, '3.01')) {
            return 'RECEITA_PF';
        }

        // Qualquer coisa em 3.0x onde x > 1
        if (preg_match('/^3\.0[2-9]/', $codigo)) {
            return 'DESPESA';
        }

        return 'PENDENTE_CLASSIFICACAO';
    }

    /**
     * Classifica baseado apenas no tipo do movimento
     */
    private function classificarPorTipo(?string $tipo): string
    {
        if (empty($tipo)) {
            return 'PENDENTE_CLASSIFICACAO';
        }

        $tipo = strtolower(trim($tipo));

        // Receitas
        if (in_array($tipo, ['receita', 'entrada', 'credito', 'c'])) {
            return 'RECEITA_PF'; // Default para PF quando não sabemos
        }

        // Despesas
        if (in_array($tipo, ['despesa', 'saida', 'debito', 'd'])) {
            return 'DESPESA';
        }

        return 'PENDENTE_CLASSIFICACAO';
    }

    /**
     * Importa planos de contas únicos de movimentos
     *
     * @param array $movimentos Array de movimentos
     * @return int Quantidade de regras importadas
     */
    public function importarDoDataJuri(array $movimentos): int
    {
        $importados = 0;
        $planosUnicos = $this->extrairPlanosUnicos($movimentos);

        foreach ($planosUnicos as $plano) {
            // Verificar se já existe
            $existe = ClassificacaoRegra::where('codigo_plano', $plano['codigo'])->exists();

            if ($existe) {
                continue;
            }

            // Criar nova regra inativa (usuário precisa revisar)
            ClassificacaoRegra::create([
                'codigo_plano' => $plano['codigo'],
                'nome_plano' => $plano['nome'],
                'classificacao' => $this->inferirPorPadraoContabil($plano['codigo']),
                'tipo_movimento' => $this->normalizarTipo($plano['tipo']),
                'origem' => 'datajuri',
                'ativo' => false,
                'prioridade' => $this->calcularPrioridade($plano['codigo']),
                'observacoes' => 'Importado automaticamente do DataJuri',
            ]);

            $importados++;
        }

        Log::info("Importação do DataJuri concluída", [
            'total_importados' => $importados,
            'total_analisados' => count($planosUnicos),
        ]);

        return $importados;
    }

    /**
     * Extrai planos únicos de uma lista de movimentos
     */
    private function extrairPlanosUnicos(array $movimentos): array
    {
        $planos = [];
        $vistos = [];

        foreach ($movimentos as $movimento) {
            $codigo = $movimento['codigo_plano'] ?? null;
            $nome = $movimento['plano_contas'] ?? 'Sem nome';
            $tipo = $movimento['tipo'] ?? 'INDEFINIDO';

            if (empty($codigo) || in_array($codigo, $vistos)) {
                continue;
            }

            $planos[] = [
                'codigo' => $codigo,
                'nome' => $nome,
                'tipo' => $tipo,
            ];

            $vistos[] = $codigo;
        }

        return $planos;
    }

    /**
     * Normaliza tipo de movimento
     */
    private function normalizarTipo(?string $tipo): string
    {
        if (empty($tipo)) {
            return 'INDEFINIDO';
        }

        $tipo = strtolower(trim($tipo));

        if (in_array($tipo, ['receita', 'entrada', 'credito', 'c'])) {
            return 'RECEITA';
        }

        if (in_array($tipo, ['despesa', 'saida', 'debito', 'd'])) {
            return 'DESPESA';
        }

        return 'INDEFINIDO';
    }

    /**
     * Calcula prioridade baseada na especificidade do código
     */
    private function calcularPrioridade(string $codigo): int
    {
        $niveis = substr_count($codigo, '.');

        return match($niveis) {
            0 => 10,
            1 => 20,
            2 => 30,
            3 => 40,
            default => 50,
        };
    }

    /**
     * Reclassifica todos os movimentos pendentes
     */
    public function reclassificarMovimentos(): array
    {
        $stats = [
            'total_analisados' => 0,
            'reclassificados' => 0,
            'pendentes' => 0,
            'por_classificacao' => [],
        ];

        // Buscar movimentos pendentes ou sem classificação
        $movimentos = Movimento::where(function($q) {
            $q->whereIn('classificacao', ['PENDENTE_CLASSIFICACAO', ''])
              ->orWhereNull('classificacao');
        })->get();

        $stats['total_analisados'] = $movimentos->count();

        foreach ($movimentos as $movimento) {
            $novaClassificacao = $this->classificar(
                $movimento->codigo_plano,
                $movimento->tipo_classificacao ?? $movimento->tipo ?? null
            );

            if ($novaClassificacao !== 'PENDENTE_CLASSIFICACAO') {
                $movimento->classificacao = $novaClassificacao;
                $movimento->save();

                $stats['reclassificados']++;
                $stats['por_classificacao'][$novaClassificacao] =
                    ($stats['por_classificacao'][$novaClassificacao] ?? 0) + 1;
            } else {
                $stats['pendentes']++;
            }
        }

        Log::info("Reclassificação em massa concluída", $stats);

        return $stats;
    }

    /**
     * Reclassifica TODOS os movimentos (não só pendentes)
     */
    public function reclassificarTodos(): array
    {
        $stats = [
            'total_analisados' => 0,
            'atualizados' => 0,
            'por_classificacao' => [],
        ];

        DB::table('movimentos')
            ->whereNotNull('codigo_plano')
            ->orderBy('id')
            ->chunk(500, function ($movimentos) use (&$stats) {
                foreach ($movimentos as $mov) {
                    $stats['total_analisados']++;
                    
                    $novaClassificacao = $this->classificar(
                        $mov->codigo_plano,
                        $mov->tipo_classificacao ?? null
                    );

                    if ($mov->classificacao !== $novaClassificacao) {
                        DB::table('movimentos')
                            ->where('id', $mov->id)
                            ->update(['classificacao' => $novaClassificacao]);

                        $stats['atualizados']++;
                    }

                    $stats['por_classificacao'][$novaClassificacao] =
                        ($stats['por_classificacao'][$novaClassificacao] ?? 0) + 1;
                }
            });

        Log::info("Reclassificação total concluída", $stats);

        return $stats;
    }

    /**
     * Valida se uma classificação é válida
     */
    public function classificacaoValida(string $classificacao): bool
    {
        return array_key_exists($classificacao, ClassificacaoRegra::CLASSIFICACOES);
    }

    /**
     * Retorna lista de classificações disponíveis
     */
    public function listarClassificacoes(): array
    {
        return ClassificacaoRegra::CLASSIFICACOES;
    }

    /**
     * Retorna lista de tipos de movimento disponíveis
     */
    public function listarTiposMovimento(): array
    {
        return ClassificacaoRegra::TIPOS_MOVIMENTO;
    }
}
