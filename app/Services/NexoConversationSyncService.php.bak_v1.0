<?php

namespace App\Services;

use App\Models\WaConversation;
use App\Models\WaMessage;
use App\Models\WaEvent;
use App\Models\Lead;
use App\Models\Cliente;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\DB;

class NexoConversationSyncService
{
    private SendPulseWhatsAppService $sendpulse;

    public function __construct(SendPulseWhatsAppService $sendpulse)
    {
        $this->sendpulse = $sendpulse;
    }

    // ═══════════════════════════════════════════════════════
    // PROCESSAMENTO DE WEBHOOK
    // ═══════════════════════════════════════════════════════

    /**
     * Processa payload de webhook incoming_message.
     * Cria/atualiza conversa e insere mensagem.
     *
     * @param array $rawPayload Payload bruto do webhook SendPulse.
     * @return bool
     */
    public function syncConversationFromWebhook(array $rawPayload): bool
    {
        $parsed = SendPulseWhatsAppService::parseWebhookIncomingMessage($rawPayload);
        if (!$parsed) {
            return false;
        }

        try {
            DB::beginTransaction();

            $phone = WaConversation::normalizePhone($parsed['phone']);

            // Upsert da conversa por contact_id (chave mais estável)
            $conversation = WaConversation::where('contact_id', $parsed['contact_id'])
                ->first();

            if (!$conversation && $phone) {
                $conversation = WaConversation::where('phone', $phone)->first();
            }

            $now = now();
            $sentAt = \Carbon\Carbon::createFromTimestamp($parsed['timestamp']);

            if (!$conversation) {
                $conversation = WaConversation::create([
                    'provider'        => 'sendpulse',
                    'contact_id'      => $parsed['contact_id'],
                    'phone'           => $phone,
                    'name'            => $parsed['contact_name'] ?: null,
                    'status'          => 'open',
                    'last_message_at' => $sentAt,
                    'last_incoming_at' => $sentAt,
                    'unread_count'    => 1,
                ]);

                // Tentar vincular automaticamente a lead/cliente existente
                $this->autoLink($conversation);
            } else {
                // Atualizar conversa existente
                $updateData = [
                    'last_message_at'  => $sentAt,
                    'last_incoming_at' => $sentAt,
                    'unread_count'     => DB::raw('unread_count + 1'),
                ];

                // Reabrir se estava fechada
                if ($conversation->status === 'closed') {
                    $updateData['status'] = 'open';
                }

                // Atualizar contact_id se não tinha
                if (empty($conversation->contact_id) && !empty($parsed['contact_id'])) {
                    $updateData['contact_id'] = $parsed['contact_id'];
                }

                // Atualizar nome se não tinha
                if (empty($conversation->name) && !empty($parsed['contact_name'])) {
                    $updateData['name'] = $parsed['contact_name'];
                }

                // Atualizar phone se não tinha
                if (empty($conversation->phone) && !empty($phone)) {
                    $updateData['phone'] = $phone;
                }

                $conversation->update($updateData);
                $conversation->refresh();
            }

            // Inserir mensagem (verificar duplicata por provider_message_id)
            $msgExists = false;
            if (!empty($parsed['message_id'])) {
                $msgExists = WaMessage::where('provider_message_id', $parsed['message_id'])->exists();
            }

            if (!$msgExists) {
                WaMessage::create([
                    'conversation_id'    => $conversation->id,
                    'provider_message_id' => $parsed['message_id'] ?: null,
                    'direction'          => WaMessage::DIRECTION_INCOMING,
                    'is_human'           => false,
                    'message_type'       => $parsed['message_type'],
                    'body'               => $parsed['text'],
                    'raw_payload'        => $this->safePayloadForStorage($rawPayload),
                    'sent_at'            => $sentAt,
                ]);
            }

            // Registrar evento de auditoria
            WaEvent::log(WaEvent::TYPE_WEBHOOK_RECEIVED, $conversation->id, [
                'contact_id' => $parsed['contact_id'],
                'phone'      => $phone,
                'msg_type'   => $parsed['message_type'],
            ]);

            DB::commit();
            return true;
        } catch (\Throwable $e) {
            DB::rollBack();
            Log::error('NexoSync: falha ao processar webhook', [
                'error' => $e->getMessage(),
                'trace' => mb_substr($e->getTraceAsString(), 0, 500),
            ]);

            WaEvent::log(WaEvent::TYPE_ERROR, null, [
                'error'   => $e->getMessage(),
                'context' => 'syncConversationFromWebhook',
            ]);

            return false;
        }
    }

    // ═══════════════════════════════════════════════════════
    // SINCRONIZAÇÃO DE MENSAGENS (POLLING)
    // ═══════════════════════════════════════════════════════

    /**
     * Sincroniza mensagens de um chat específico via API.
     * Usado pelo polling do chat aberto (8-12s).
     *
     * @param WaConversation $conversation
     * @param int            $limit
     * @return int           Quantidade de mensagens novas inseridas.
     */
    public function syncMessages(WaConversation $conversation, int $limit = 50): int
    {
        if (empty($conversation->chat_id) && empty($conversation->contact_id)) {
            Log::warning('NexoSync: sem chat_id nem contact_id para sync', [
                'conversation_id' => $conversation->id,
            ]);
            return 0;
        }

        // Determinar chat_id a usar
        $chatId = $conversation->chat_id;

        // Se não temos chat_id, tentar obter pelo contact_id
        if (empty($chatId) && !empty($conversation->contact_id)) {
            $chatId = $conversation->contact_id;
        }

        // Buscar mensagens da API
        $since = null;
        $lastMsg = $conversation->messages()->orderBy('sent_at', 'desc')->first();
        if ($lastMsg && $lastMsg->sent_at) {
            $since = $lastMsg->sent_at->toISOString();
        }

        $messages = $this->sendpulse->getChatMessages($chatId, $limit, $since);
        if (!$messages || !is_array($messages)) {
            return 0;
        }

        // Se a resposta tem 'data' como array, usar esse
        if (isset($messages['data']) && is_array($messages['data'])) {
            $messages = $messages['data'];
        }

        $newCount = 0;

        foreach ($messages as $msg) {
            if (!is_array($msg)) {
                continue;
            }

            $providerMsgId = data_get($msg, 'id') ?? data_get($msg, 'message_id');

            // Verificar duplicata
            if ($providerMsgId && WaMessage::where('provider_message_id', $providerMsgId)->exists()) {
                continue;
            }

            $direction   = SendPulseWhatsAppService::extractDirection($msg);
            $text        = SendPulseWhatsAppService::extractText($msg);
            $messageType = SendPulseWhatsAppService::extractMessageType($msg);

            // Determinar sent_at
            $sentAtRaw = data_get($msg, 'date') ?? data_get($msg, 'created_at') ?? data_get($msg, 'timestamp');
            $sentAt = $sentAtRaw ? $this->parseTimestamp($sentAtRaw) : now();

            WaMessage::create([
                'conversation_id'     => $conversation->id,
                'provider_message_id' => $providerMsgId,
                'direction'           => $direction,
                'is_human'            => false, // mensagens da API são bot/cliente, não humano
                'message_type'        => $messageType,
                'body'                => $text,
                'raw_payload'         => $this->safePayloadForStorage($msg),
                'sent_at'             => $sentAt,
            ]);

            $newCount++;
        }

        // Atualizar contadores da conversa se teve mensagens novas
        if ($newCount > 0) {
            $lastIncoming = $conversation->messages()
                ->incoming()
                ->orderBy('sent_at', 'desc')
                ->first();

            $updateData = [
                'last_message_at' => $conversation->messages()->orderBy('sent_at', 'desc')->value('sent_at'),
            ];

            if ($lastIncoming) {
                $updateData['last_incoming_at'] = $lastIncoming->sent_at;
            }

            $conversation->update($updateData);

            WaEvent::log(WaEvent::TYPE_SYNC_RUN, $conversation->id, [
                'new_messages' => $newCount,
                'total_fetched' => count($messages),
            ]);
        }

        return $newCount;
    }

    // ═══════════════════════════════════════════════════════
    // ENVIO DE MENSAGEM (HUMANO)
    // ═══════════════════════════════════════════════════════

    /**
     * Envia mensagem humana pela conversa.
     * Salva no banco local com is_human=true.
     *
     * @param WaConversation $conversation
     * @param string         $text
     * @param int            $userId  ID do usuário que enviou.
     * @return array         ['success' => bool, 'message' => WaMessage|null, 'error' => string|null]
     */
    public function sendHumanMessage(WaConversation $conversation, string $text, int $userId): array
    {
        $text = trim($text);
        if (empty($text)) {
            return ['success' => false, 'message' => null, 'error' => 'Mensagem vazia'];
        }

        // Tentar enviar via contact_id primeiro, senão por telefone
        if (!empty($conversation->contact_id)) {
            $result = $this->sendpulse->sendMessage($conversation->contact_id, $text);
        } elseif (!empty($conversation->phone)) {
            $result = $this->sendpulse->sendMessageByPhone($conversation->phone, $text);
        } else {
            return ['success' => false, 'message' => null, 'error' => 'Conversa sem contact_id nem telefone'];
        }

        if (!$result['success']) {
            WaEvent::log(WaEvent::TYPE_ERROR, $conversation->id, [
                'error'   => $result['error'],
                'context' => 'sendHumanMessage',
                'user_id' => $userId,
            ]);

            return ['success' => false, 'message' => null, 'error' => $result['error']];
        }

        // Salvar mensagem no banco local
        $waMessage = WaMessage::create([
            'conversation_id'     => $conversation->id,
            'provider_message_id' => data_get($result, 'data.id') ?? data_get($result, 'data.message_id'),
            'direction'           => WaMessage::DIRECTION_OUTGOING,
            'is_human'            => true,
            'message_type'        => 'text',
            'body'                => $text,
            'sent_at'             => now(),
        ]);

        // Atualizar conversa
        $updateData = ['last_message_at' => now()];

        // Se é a primeira resposta humana, registrar SLA
        if (!$conversation->first_response_at) {
            $updateData['first_response_at'] = now();
        }

        // Atribuir responsável se não tem
        if (!$conversation->assigned_user_id) {
            $updateData['assigned_user_id'] = $userId;
        }

        // Zerar unread (humano respondeu)
        $updateData['unread_count'] = 0;

        $conversation->update($updateData);

        WaEvent::log(WaEvent::TYPE_SEND_MESSAGE, $conversation->id, [
            'user_id'   => $userId,
            'text_size' => strlen($text),
        ]);

        return ['success' => true, 'message' => $waMessage, 'error' => null];
    }

    // ═══════════════════════════════════════════════════════
    // VINCULAÇÃO AUTOMÁTICA
    // ═══════════════════════════════════════════════════════

    /**
     * Tenta vincular conversa a Lead e/ou Cliente existente pelo telefone.
     */
    public function autoLink(WaConversation $conversation): void
    {
        if (empty($conversation->phone)) {
            return;
        }

        $phone = $conversation->phone;

        // Procurar lead por telefone (normalizado)
        if (!$conversation->linked_lead_id) {
            $lead = Lead::where(function ($q) use ($phone) {
                $q->where('telefone', $phone)
                  ->orWhere('telefone', 'LIKE', '%' . substr($phone, -9) . '%');
            })->first();

            if ($lead) {
                $conversation->update(['linked_lead_id' => $lead->id]);
            }
        }

        // Procurar cliente por telefone
        if (!$conversation->linked_cliente_id) {
            $cliente = Cliente::where(function ($q) use ($phone) {
                $q->where('telefone', $phone)
                  ->orWhere('telefone', 'LIKE', '%' . substr($phone, -9) . '%');
            })->first();

            if ($cliente) {
                $conversation->update(['linked_cliente_id' => $cliente->id]);
            }
        }
    }

    // ═══════════════════════════════════════════════════════
    // HELPERS INTERNOS
    // ═══════════════════════════════════════════════════════

    /**
     * Converte timestamp variado para Carbon.
     */
    private function parseTimestamp($raw): \Carbon\Carbon
    {
        if ($raw instanceof \Carbon\Carbon) {
            return $raw;
        }

        // Unix timestamp (int ou string numérica)
        if (is_numeric($raw) && strlen((string) $raw) >= 10) {
            return \Carbon\Carbon::createFromTimestamp((int) $raw);
        }

        // ISO string
        try {
            return \Carbon\Carbon::parse($raw);
        } catch (\Throwable $e) {
            return now();
        }
    }

    /**
     * Limita tamanho do payload para armazenamento.
     * Remove tokens e trunca se necessário.
     */
    private function safePayloadForStorage($payload): ?array
    {
        if (!is_array($payload)) {
            return null;
        }

        // Remover campos sensíveis recursivamente
        $sensitiveKeys = ['token', 'access_token', 'api_key', 'secret', 'password', 'authorization'];
        array_walk_recursive($payload, function (&$value, $key) use ($sensitiveKeys) {
            if (in_array(strtolower($key), $sensitiveKeys, true)) {
                $value = '***';
            }
        });

        // Verificar tamanho (max 50KB para raw_payload)
        $json = json_encode($payload, JSON_UNESCAPED_UNICODE);
        if ($json && strlen($json) > 51200) {
            return ['_truncated' => true, 'original_size' => strlen($json)];
        }

        return $payload;
    }
}
