<?php

namespace App\Http\Controllers;

use App\Models\WaConversation;
use App\Models\WaMessage;
use App\Models\WaEvent;
use App\Models\User;
use App\Services\SendPulseWhatsAppService;
use App\Services\NexoConversationSyncService;
use App\Services\NexoDataJuriService;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;

class NexoAtendimentoController extends Controller
{
    // ═══════════════════════════════════════════════════════════════
    // FASE 1 — Métodos existentes (v1.1)
    // ═══════════════════════════════════════════════════════════════

    /**
     * View principal do atendimento (3 colunas).
     */
    public function index()
    {
        $users = User::orderBy('name')->get();
        return view('nexo.atendimento.index', compact('users'));
    }

    /**
     * Lista de conversas (paginado, filtros).
     * GET /nexo/atendimento/conversas
     */
    public function conversas(Request $request)
    {
        $query = WaConversation::with('assignedUser')
            ->orderByDesc('last_message_at');

        if ($request->filled('status')) {
            $query->where('status', $request->status);
        }

        if ($request->filled('unread') && $request->unread == '1') {
            $query->where('unread_count', '>', 0);
        }

        if ($request->filled('responsavel')) {
            $query->where('assigned_user_id', $request->responsavel);
        }

        if ($request->filled('tipo')) {
            switch ($request->tipo) {
                case 'lead':
                    $query->whereNotNull('linked_lead_id');
                    break;
                case 'cliente':
                    $query->whereNotNull('linked_cliente_id');
                    break;
                case 'indefinido':
                    $query->whereNull('linked_lead_id')->whereNull('linked_cliente_id');
                    break;
            }
        }

        $result = $query->paginate(30);

        return response()->json($result);
    }

    /**
     * Detalhe de uma conversa com mensagens.
     * GET /nexo/atendimento/conversas/{id}
     */
    public function conversa(int $id)
    {
        $conversation = WaConversation::with('assignedUser')->findOrFail($id);

        $messages = WaMessage::where('conversation_id', $id)
            ->orderBy('sent_at', 'asc')
            ->get();

        return response()->json([
            'conversation' => $conversation,
            'messages' => $messages,
        ]);
    }

    /**
     * Enviar mensagem via SendPulse.
     * POST /nexo/atendimento/conversas/{id}/mensagens
     */
    public function enviarMensagem(Request $request, int $id)
    {
        $request->validate(['text' => 'required|string|max:4096']);

        $conversation = WaConversation::findOrFail($id);

        try {
            $spService = app(SendPulseWhatsAppService::class);
            $spService->sendTextMessage($conversation->contact_id, $request->text);

            $message = WaMessage::create([
                'conversation_id' => $id,
                'direction' => WaMessage::DIRECTION_OUTGOING,
                'is_human' => true,
                'message_type' => 'text',
                'body' => $request->text,
                'sent_at' => now(),
            ]);

            // SLA: marcar primeira resposta
            if (!$conversation->first_response_at) {
                $conversation->first_response_at = now();
            }
            $conversation->last_message_at = now();
            $conversation->save();

            WaEvent::log('send_message', $id, ['text_length' => strlen($request->text)]);

            return response()->json(['success' => true, 'message' => $message]);

        } catch (\Throwable $e) {
            Log::error('Erro ao enviar mensagem NEXO', [
                'conversa_id' => $id,
                'error' => $e->getMessage(),
            ]);

            WaEvent::log('error', $id, [
                'action' => 'send_message',
                'error' => $e->getMessage(),
            ]);

            return response()->json([
                'success' => false,
                'error' => 'Falha ao enviar mensagem.',
            ], 500);
        }
    }

    /**
     * Polling de mensagens novas (rate-limited).
     * GET /nexo/atendimento/conversas/{id}/poll
     */
    public function pollMessages(int $id)
    {
        $conversation = WaConversation::findOrFail($id);
        $conversationId = $conversation->id;
        $userId = auth()->id() ?? 0;

        // Rate-limit: mínimo 8s entre chamadas por userId+conversaId
        $throttleKey = "nexo_poll_throttle_{$userId}_{$conversationId}";
        if (Cache::has($throttleKey)) {
            $messages = WaMessage::where('conversation_id', $conversationId)
                ->orderBy('sent_at', 'asc')
                ->get();

            return response()->json([
                'throttled' => true,
                'new_count' => 0,
                'messages' => $messages,
            ]);
        }

        // Lock para impedir sync concorrente
        $lock = Cache::lock("nexo_poll_{$conversationId}", 10);
        if (!$lock->get()) {
            $messages = WaMessage::where('conversation_id', $conversationId)
                ->orderBy('sent_at', 'asc')
                ->get();

            return response()->json([
                'throttled' => true,
                'new_count' => 0,
                'messages' => $messages,
            ]);
        }

        try {
            // Sync com SendPulse
            $syncService = app(NexoConversationSyncService::class);
            $syncService->syncConversation($conversation);

            Cache::put($throttleKey, true, 8);

            $messages = WaMessage::where('conversation_id', $conversationId)
                ->orderBy('sent_at', 'asc')
                ->get();

            return response()->json([
                'throttled' => false,
                'new_count' => $messages->count(),
                'messages' => $messages,
            ]);

        } catch (\Throwable $e) {
            Log::warning('Poll sync error', [
                'conversa_id' => $conversationId,
                'error' => $e->getMessage(),
            ]);

            $messages = WaMessage::where('conversation_id', $conversationId)
                ->orderBy('sent_at', 'asc')
                ->get();

            return response()->json([
                'throttled' => false,
                'new_count' => $messages->count(),
                'messages' => $messages,
            ]);
        } finally {
            $lock->release();
        }
    }

    /**
     * Atribuir responsável à conversa.
     * PATCH /nexo/atendimento/conversas/{id}/assign
     */
    public function assignUser(Request $request, int $id)
    {
        $conversation = WaConversation::findOrFail($id);
        $conversation->assigned_user_id = $request->input('user_id') ?: null;
        $conversation->save();

        return response()->json(['success' => true]);
    }

    /**
     * Alterar status da conversa (open/closed).
     * PATCH /nexo/atendimento/conversas/{id}/status
     */
    public function changeStatus(Request $request, int $id)
    {
        $request->validate(['status' => 'required|in:open,closed']);

        $conversation = WaConversation::findOrFail($id);
        $conversation->status = $request->status;
        $conversation->save();

        return response()->json(['success' => true, 'status' => $conversation->status]);
    }

    /**
     * Vincular lead à conversa.
     * POST /nexo/atendimento/conversas/{id}/link-lead
     */
    public function linkLead(Request $request, int $id)
    {
        $request->validate(['lead_id' => 'required|integer|exists:leads,id']);

        $conversation = WaConversation::findOrFail($id);
        $conversation->linked_lead_id = $request->lead_id;
        $conversation->save();

        return response()->json(['success' => true]);
    }

    /**
     * Vincular cliente à conversa.
     * POST /nexo/atendimento/conversas/{id}/link-cliente
     */
    public function linkCliente(Request $request, int $id)
    {
        $request->validate(['cliente_id' => 'required|integer|exists:clientes,id']);

        $conversation = WaConversation::findOrFail($id);
        $conversation->linked_cliente_id = $request->cliente_id;
        $conversation->save();

        return response()->json(['success' => true]);
    }

    /**
     * Contexto 360 da conversa (lead + cliente + processos + contas).
     * GET /nexo/atendimento/conversas/{id}/contexto
     */
    public function contexto360(int $id)
    {
        $conversation = WaConversation::findOrFail($id);

        $context = [
            'link_type' => $conversation->link_type,
            'lead' => null,
            'cliente' => null,
        ];

        // Bloco Lead (try-catch individual — v1.1 BUG #006)
        try {
            if ($conversation->linked_lead_id && $conversation->lead) {
                $context['lead'] = $conversation->lead->toArray();
            }
        } catch (\Throwable $e) {
            $context['lead'] = ['_error' => $e->getMessage()];
        }

        // Bloco Cliente (try-catch individual — v1.1 BUG #006)
        try {
            if ($conversation->linked_cliente_id && $conversation->cliente) {
                $cliente = $conversation->cliente;
                $clienteData = $cliente->toArray();

                // Processos ativos
                try {
                    if (method_exists($cliente, 'processos')) {
                        $clienteData['processos_ativos'] = $cliente->processos()
                            ->where('status', 'Ativo')
                            ->limit(10)
                            ->get()
                            ->toArray();
                    }
                } catch (\Throwable $e) {
                    $clienteData['processos_ativos'] = [];
                    $clienteData['_processos_error'] = $e->getMessage();
                }

                // Contas abertas
                try {
                    if (method_exists($cliente, 'contasReceber')) {
                        $clienteData['contas_abertas'] = $cliente->contasReceber()
                            ->where('status', 'aberta')
                            ->limit(10)
                            ->get()
                            ->toArray();
                    }
                } catch (\Throwable $e) {
                    $clienteData['contas_abertas'] = [];
                    $clienteData['_contas_error'] = $e->getMessage();
                }

                $context['cliente'] = $clienteData;
            }
        } catch (\Throwable $e) {
            $context['cliente'] = ['_error' => $e->getMessage()];
        }

        return response()->json($context);
    }

    // ═══════════════════════════════════════════════════════════════
    // INTEGRAÇÃO NEXO ↔ DATAJURI — 6 novos métodos
    // ═══════════════════════════════════════════════════════════════

    /**
     * Auto-link: normaliza telefone, busca cliente, vincula se único.
     * GET /nexo/atendimento/conversas/{id}/auto-link-cliente
     */
    public function autoLinkCliente(int $id)
    {
        $conversa = WaConversation::findOrFail($id);
        $service = new NexoDataJuriService();

        $resultado = $service->tentarVincularCliente($conversa);

        return response()->json([
            'status' => $resultado['status'],
            'auto_linked' => $resultado['auto_linked'],
            'clientes' => $resultado['clientes']->map(function ($c) {
                return [
                    'id' => $c->id,
                    'nome' => $c->nome,
                    'tipo_pessoa' => $c->tipo_pessoa ?? ($c->cnpj ? 'PJ' : 'PF'),
                    'documento' => $c->documento ?? $c->cpf ?? $c->cnpj ?? '—',
                    'telefone' => $c->telefone ?? '—',
                ];
            })->values(),
            'linked_cliente_id' => $conversa->linked_cliente_id,
        ]);
    }

    /**
     * Busca manual de clientes por nome/CPF/CNPJ/telefone.
     * GET /nexo/atendimento/conversas/{id}/buscar-clientes?q=termo
     */
    public function buscarClientes(int $id)
    {
        $termo = request()->get('q', '');
        $service = new NexoDataJuriService();

        $clientes = $service->buscarClientes($termo);

        return response()->json([
            'clientes' => $clientes->map(function ($c) {
                return [
                    'id' => $c->id,
                    'nome' => $c->nome,
                    'tipo_pessoa' => $c->tipo_pessoa ?? ($c->cnpj ? 'PJ' : 'PF'),
                    'documento' => $c->documento ?? $c->cpf ?? $c->cnpj ?? '—',
                    'telefone' => $c->telefone ?? '—',
                ];
            })->values(),
            'total' => $clientes->count(),
        ]);
    }

    /**
     * Painel completo DataJuri: cliente + processos ativos + prazos.
     * GET /nexo/atendimento/conversas/{id}/contexto-datajuri?processo_filtro_id=X
     */
    public function contextoDataJuri(int $id)
    {
        $conversa = WaConversation::findOrFail($id);

        if (!$conversa->linked_cliente_id) {
            return response()->json([
                'error' => 'Nenhum cliente vinculado a esta conversa.',
                'linked_cliente_id' => null,
            ], 200);
        }

        $processoFiltroId = request()->integer('processo_filtro_id') ?: null;
        $service = new NexoDataJuriService();

        try {
            $contexto = $service->contextoDataJuri($conversa->linked_cliente_id, $processoFiltroId);
            $contexto['linked_processo_id'] = $conversa->linked_processo_id;

            return response()->json($contexto);
        } catch (\Throwable $e) {
            Log::error('Erro contextoDataJuri', [
                'conversa_id' => $id,
                'cliente_id' => $conversa->linked_cliente_id,
                'error' => $e->getMessage(),
            ]);

            return response()->json([
                'error' => 'Erro ao carregar contexto DataJuri.',
                '_debug' => config('app.debug') ? $e->getMessage() : null,
            ], 200);
        }
    }

    /**
     * Lista processos ativos do cliente vinculado.
     * GET /nexo/atendimento/conversas/{id}/processos-cliente
     */
    public function processosCliente(int $id)
    {
        $conversa = WaConversation::findOrFail($id);

        if (!$conversa->linked_cliente_id) {
            return response()->json(['processos' => [], 'error' => 'Sem cliente vinculado']);
        }

        $service = new NexoDataJuriService();
        $processos = $service->processosDoCliente($conversa->linked_cliente_id);

        return response()->json([
            'processos' => $processos->map(function ($p) {
                return [
                    'id' => $p->id,
                    'datajuri_id' => $p->datajuri_id,
                    'numero' => $p->numero ?? $p->pasta ?? '—',
                    'status' => $p->status,
                    'assunto' => $p->assunto ?? '—',
                    'natureza' => $p->natureza,
                ];
            })->values(),
            'linked_processo_id' => $conversa->linked_processo_id,
        ]);
    }

    /**
     * Vincula processo à conversa.
     * POST /nexo/atendimento/conversas/{id}/link-processo
     */
    public function linkProcesso(int $id)
    {
        $conversa = WaConversation::findOrFail($id);
        $processoId = (int) request()->input('processo_id');

        if (!$processoId) {
            return response()->json(['success' => false, 'error' => 'processo_id obrigatório'], 422);
        }

        $service = new NexoDataJuriService();
        $ok = $service->vincularProcesso($conversa, $processoId);

        if (!$ok) {
            return response()->json([
                'success' => false,
                'error' => 'Processo não encontrado ou não pertence ao cliente vinculado.',
            ], 422);
        }

        return response()->json([
            'success' => true,
            'linked_processo_id' => $conversa->linked_processo_id,
        ]);
    }

    /**
     * Remove vínculo de processo.
     * DELETE /nexo/atendimento/conversas/{id}/unlink-processo
     */
    public function unlinkProcesso(int $id)
    {
        $conversa = WaConversation::findOrFail($id);
        $service = new NexoDataJuriService();
        $service->desvincularProcesso($conversa);

        return response()->json(['success' => true, 'linked_processo_id' => null]);
    }
}
